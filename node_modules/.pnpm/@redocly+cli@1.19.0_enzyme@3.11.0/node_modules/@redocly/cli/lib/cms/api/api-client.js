"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReuniteApiClient = void 0;
const fetch_with_timeout_1 = require("../../utils/fetch-with-timeout");
const node_fetch_1 = require("node-fetch");
const FormData = require("form-data");
const openapi_core_1 = require("@redocly/openapi-core");
class RemotesApiClient {
    constructor(domain, apiKey) {
        this.domain = domain;
        this.apiKey = apiKey;
    }
    async getParsedResponse(response) {
        const responseBody = await response.json();
        if (response.ok) {
            return responseBody;
        }
        throw new Error(responseBody.title || response.statusText);
    }
    async getDefaultBranch(organizationId, projectId) {
        const response = await (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/source`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.apiKey}`,
            },
        });
        if (!response) {
            throw new Error(`Failed to get default branch.`);
        }
        try {
            const source = await this.getParsedResponse(response);
            return source.branchName;
        }
        catch (err) {
            throw new Error(`Failed to fetch default branch: ${err.message || 'Unknown error'}`);
        }
    }
    async upsert(organizationId, projectId, remote) {
        const response = await (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.apiKey}`,
            },
            body: JSON.stringify({
                mountPath: remote.mountPath,
                mountBranchName: remote.mountBranchName,
                type: 'CICD',
                autoMerge: true,
            }),
        });
        if (!response) {
            throw new Error(`Failed to upsert.`);
        }
        try {
            return await this.getParsedResponse(response);
        }
        catch (err) {
            throw new Error(`Failed to upsert remote: ${err.message || 'Unknown error'}`);
        }
    }
    async push(organizationId, projectId, payload, files) {
        const formData = new FormData();
        formData.append('remoteId', payload.remoteId);
        formData.append('commit[message]', payload.commit.message);
        formData.append('commit[author][name]', payload.commit.author.name);
        formData.append('commit[author][email]', payload.commit.author.email);
        formData.append('commit[branchName]', payload.commit.branchName);
        payload.commit.url && formData.append('commit[url]', payload.commit.url);
        payload.commit.namespace && formData.append('commit[namespaceId]', payload.commit.namespace);
        payload.commit.sha && formData.append('commit[sha]', payload.commit.sha);
        payload.commit.repository && formData.append('commit[repositoryId]', payload.commit.repository);
        payload.commit.createdAt && formData.append('commit[createdAt]', payload.commit.createdAt);
        for (const file of files) {
            formData.append(`files[${file.path}]`, file.stream);
        }
        payload.isMainBranch && formData.append('isMainBranch', 'true');
        const response = await (0, node_fetch_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
            },
            body: formData,
            agent: (0, openapi_core_1.getProxyAgent)(),
        });
        try {
            return await this.getParsedResponse(response);
        }
        catch (err) {
            throw new Error(`Failed to push: ${err.message || 'Unknown error'}`);
        }
    }
    async getRemotesList(organizationId, projectId, mountPath) {
        const response = await (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes?filter=mountPath:/${mountPath}/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.apiKey}`,
            },
        });
        if (!response) {
            throw new Error(`Failed to get remotes list.`);
        }
        try {
            return await this.getParsedResponse(response);
        }
        catch (err) {
            throw new Error(`Failed to get remote list: ${err.message || 'Unknown error'}`);
        }
    }
    async getPush({ organizationId, projectId, pushId, }) {
        const response = await (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes/${pushId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${this.apiKey}`,
            },
        });
        if (!response) {
            throw new Error(`Failed to get push status.`);
        }
        try {
            return await this.getParsedResponse(response);
        }
        catch (err) {
            throw new Error(`Failed to get push status: ${err.message || 'Unknown error'}`);
        }
    }
}
class ReuniteApiClient {
    constructor(domain, apiKey) {
        this.domain = domain;
        this.apiKey = apiKey;
        this.remotes = new RemotesApiClient(this.domain, this.apiKey);
    }
}
exports.ReuniteApiClient = ReuniteApiClient;
